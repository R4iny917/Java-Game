<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Server.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">final_homework</a> &gt; <a href="index.source.html" class="el_package">com.homework.multiplayer</a> &gt; <span class="el_source">Server.java</span></div><h1>Server.java</h1><pre class="source lang-java linenums">package com.homework.multiplayer;

import java.awt.Component;
import java.awt.event.KeyEvent;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.Channel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;
import com.homework.world.*;
import com.homework.screen.*;;
/**
 * 
 * This is a simple NIO based server.
 *
 */
public class Server implements Runnable{
	private Selector selector;
    private ServerScreen screen;
	private InetSocketAddress listenAddress;
	private final static int PORT = 8000;
<span class="fc" id="L31">    public static int channel_number = 0;</span>

<span class="fc" id="L33">	public Server(String address) throws IOException {</span>
<span class="fc" id="L34">		listenAddress = new InetSocketAddress(address, PORT);</span>
<span class="fc" id="L35">	}</span>

    @Override
    public void run() {
        try {
<span class="nc" id="L40">            this.startServer();</span>
<span class="fc" id="L41">        } catch (IOException e) {</span>
<span class="fc" id="L42">            e.printStackTrace();</span>
<span class="nc" id="L43">        }</span>
<span class="fc" id="L44">    }</span>

    public void set_screen(ServerScreen screen){
<span class="fc" id="L47">        this.screen = screen;</span>
<span class="fc" id="L48">    }</span>
	/**
	 * Start the server
	 * 
	 * @throws IOException
	 */
	private void startServer() throws IOException {
<span class="fc" id="L55">		this.selector = Selector.open();</span>
<span class="fc" id="L56">		ServerSocketChannel serverChannel = ServerSocketChannel.open();</span>
<span class="fc" id="L57">		serverChannel.configureBlocking(false);</span>

		// bind server socket channel to port
<span class="fc" id="L60">		serverChannel.socket().bind(listenAddress);</span>
<span class="fc" id="L61">		serverChannel.register(this.selector, SelectionKey.OP_ACCEPT);</span>

<span class="fc" id="L63">		System.out.println(&quot;Server started on port &gt;&gt; &quot; + PORT);</span>

		while (true) {
			// wait for events
<span class="nc" id="L67">			int readyCount = selector.select();</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">			if (readyCount == 0) {</span>
<span class="nc" id="L69">				continue;</span>
			}
			// process selected keys...
<span class="nc" id="L72">			Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span>
<span class="nc" id="L73">			Iterator iterator = readyKeys.iterator();</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">			while (iterator.hasNext()) {</span>
<span class="nc" id="L75">				SelectionKey key = (SelectionKey) iterator.next();</span>
				// Remove key from set so we don't process it twice
<span class="nc" id="L77">				iterator.remove();</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">				if (!key.isValid()) {</span>
<span class="nc" id="L79">					continue;</span>
				}
<span class="nc bnc" id="L81" title="All 2 branches missed.">				if (key.isAcceptable()) { // Accept client connections</span>
<span class="nc" id="L82">					this.accept(key);</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">				} else if (key.isReadable()) { // Read from client</span>
<span class="nc" id="L84">					this.read(key);</span>
				}
<span class="nc" id="L86">			}</span>
<span class="nc" id="L87">		}</span>
	}

	// accept client connection
	private void accept(SelectionKey key) throws IOException {
<span class="nc" id="L92">		ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();</span>
<span class="nc" id="L93">		SocketChannel channel = serverChannel.accept();</span>
<span class="nc" id="L94">		channel.configureBlocking(false);</span>
<span class="nc" id="L95">		Socket socket = channel.socket();</span>
<span class="nc" id="L96">		SocketAddress remoteAddr = socket.getRemoteSocketAddress();</span>
<span class="nc" id="L97">		System.out.println(&quot;Connected to: &quot; + remoteAddr);</span>
		/*
		 * Register channel with selector for further IO (record it for read/write
		 * operations, here we have used read operation)
		 */
<span class="nc" id="L102">		channel.register(this.selector, SelectionKey.OP_READ);</span>
<span class="nc" id="L103">        String str_addr = remoteAddr.toString();</span>
<span class="nc" id="L104">        String realAddress = str_addr.substring(str_addr.length() - 5);</span>
<span class="nc" id="L105">        this.screen.create_client(Integer.valueOf(realAddress));</span>
<span class="nc" id="L106">        channel_number++;</span>
<span class="nc" id="L107">	}</span>

	// read from the socket channel
	private void read(SelectionKey key){
<span class="nc" id="L111">		SocketChannel channel = (SocketChannel) key.channel();</span>
<span class="nc" id="L112">		ByteBuffer buffer = ByteBuffer.allocate(256);</span>
<span class="nc" id="L113">		int numRead = -1;</span>
		try {
<span class="nc" id="L115">            numRead = channel.read(buffer);</span>
<span class="nc" id="L116">        } catch (IOException e) {</span>
            
<span class="nc" id="L118">            e.printStackTrace();</span>
<span class="nc" id="L119">        }</span>
<span class="nc" id="L120">        byte[] data = new byte[numRead];</span>
<span class="nc" id="L121">        System.arraycopy(buffer.array(), 0, data, 0, numRead);</span>
<span class="nc" id="L122">        String msg = new String(data);</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">		if (numRead == -1 || msg.equals(&quot;m&quot;)) {</span>
<span class="nc" id="L124">			Socket socket = channel.socket();</span>
<span class="nc" id="L125">			SocketAddress remoteAddr = socket.getRemoteSocketAddress();</span>
<span class="nc" id="L126">			System.out.println(&quot;Connection closed by client: &quot; + remoteAddr);</span>
<span class="nc" id="L127">            channel_number--;</span>
			try {
<span class="nc" id="L129">                channel.close();</span>
<span class="nc" id="L130">            } catch (IOException e) {</span>
                
<span class="nc" id="L132">                e.printStackTrace();</span>
<span class="nc" id="L133">            }</span>
<span class="nc" id="L134">			key.cancel();</span>
<span class="nc" id="L135">			return;</span>
		}

		
<span class="nc" id="L139">        Socket socket = channel.socket();</span>
<span class="nc" id="L140">        SocketAddress remoteAddr = socket.getRemoteSocketAddress();</span>
<span class="nc" id="L141">        String str_addr = remoteAddr.toString();</span>
<span class="nc" id="L142">        String realAddress = str_addr.substring(str_addr.length() - 5);</span>
        //System.out.println(&quot;Received message from: &quot; + remoteAddr);
<span class="nc" id="L144">        KeyEvent keyEvent = construct_KeyEvent(Integer.valueOf(realAddress),msg);</span>
<span class="nc" id="L145">        buffer.clear();</span>
<span class="nc" id="L146">        screen.respondToUserInput(keyEvent);</span>
        // Broadcast the message to all clients
        
<span class="nc" id="L149">	}</span>

    public void broadcast(World world) throws IOException{
<span class="nc" id="L152">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="nc" id="L153">        ObjectOutputStream oos = new ObjectOutputStream(bos);</span>
<span class="nc" id="L154">        oos.writeObject(world);</span>
<span class="nc" id="L155">        oos.flush();</span>
<span class="nc" id="L156">        byte[] data = bos.toByteArray();</span>
<span class="nc" id="L157">        ByteBuffer worldBuffer = ByteBuffer.wrap(data);</span>
<span class="nc" id="L158">        int size = data.length;</span>
        //System.out.println(&quot;Size of the serialized World object: &quot; + size + &quot; bytes&quot;);
<span class="nc" id="L160">        ByteBuffer sizeBuffer = ByteBuffer.allocate(4);  // int is 4 bytes</span>
<span class="nc" id="L161">        sizeBuffer.putInt(size);</span>
<span class="nc" id="L162">        sizeBuffer.flip();  // flip the buffer to prepare it for reading</span>
        
<span class="nc bnc" id="L164" title="All 2 branches missed.">        for (SelectionKey getkey : selector.keys()) {</span>
<span class="nc" id="L165">            Channel targetChannel = getkey.channel();</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">            if (targetChannel instanceof SocketChannel &amp;&amp; getkey.isValid()) {</span>
                //System.out.println(&quot;Here comes to broadcast&quot;);
<span class="nc" id="L168">                SocketChannel target = (SocketChannel) targetChannel;  </span>
<span class="nc" id="L169">                target.write(sizeBuffer);</span>
<span class="nc" id="L170">                sizeBuffer.rewind();  // rewind the buffer for the next write</span>

<span class="nc" id="L172">                target.write(worldBuffer);</span>
<span class="nc" id="L173">                worldBuffer.rewind();  // rewind the buffer for the next write</span>
            }
<span class="nc" id="L175">        }</span>
<span class="nc" id="L176">    }</span>

    public KeyEvent construct_KeyEvent(int id ,String msg){
<span class="fc" id="L179">        KeyEvent keyEvent = new KeyEvent(new Component(){}, id, 0, 0, KeyEvent.VK_0, '\n');</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if(msg.equals(&quot;a&quot;))keyEvent.setKeyCode(KeyEvent.VK_A);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        else if(msg.equals(&quot;w&quot;))keyEvent.setKeyCode(KeyEvent.VK_W);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        else if(msg.equals(&quot;s&quot;))keyEvent.setKeyCode(KeyEvent.VK_S);</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        else if(msg.equals(&quot;d&quot;))keyEvent.setKeyCode(KeyEvent.VK_D);</span>
<span class="fc" id="L184">        return keyEvent;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>